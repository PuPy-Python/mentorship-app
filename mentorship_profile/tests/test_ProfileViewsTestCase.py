import re
from unittest.mock import MagicMock

from django.contrib.auth.models import User
from django.test import (
    Client,
    TestCase,
    RequestFactory,
)
from django.urls import reverse
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes

from .test_utilities import UserFactory, DEFAULT_TEST_USER_PASSWORD
from ..models import Mentor, Mentee
from ..tokens import account_activation_token
from ..views import _send_registration_email, _get_user_from_uid


class ProfileViewTestCase(TestCase):
    """Unit Tests for profile views and related functions."""

    def setUp(self):
        """Create request and client obects for view tests."""
        self.client = Client()
        self.request = RequestFactory()

    def test_valid_activate_account_view(self):
        """Test the activate_account_view with a valid user and token."""
        user = UserFactory.create()
        self.assertFalse(user.profile.email_confirmed)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = account_activation_token.make_token(user)
        url_token = uid.decode('utf-8') + '/' + token

        res = self.client.get(reverse(
            'activate_account',
            kwargs={"url_token": url_token}
        ))

        # Valid response should have 200 status code and the html should
        # contain the username.
        self.assertEqual(res.status_code, 200)
        self.assertTrue(user.username in res.content.decode('utf-8'))

        same_user = User.objects.first()

        # gut check - users should be the same.
        self.assertEqual(user, same_user)
        self.assertTrue(same_user.profile.email_confirmed)

    def test_invalid_activate_account_view_no_token(self):
        """Test the activate_account_view won't work w/ bad token input."""
        uid = "bob"
        token = "supersecrettoken"
        url = "/activate_account/" + uid + "/" + token
        res = self.client.get(url, follow=True)
        self.assertEqual(
            'mentorship_profile/activation_invalid.html',
            res.templates[0].name
        )

    def test_invalid_activate_account_view_with_user_bad_token(self):
        """Test activate_account_view with wrong user token."""
        user = UserFactory.create()
        user2 = UserFactory.create()
        self.assertFalse(user.profile.email_confirmed)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = account_activation_token.make_token(user2)
        url_token = uid.decode('utf-8') + '/' + token

        res = self.client.get(reverse(
            'activate_account',
            kwargs={"url_token": url_token}
        ))
        self.assertTrue(b"Invalid activation link" in res.content)
        self.assertEqual(
            'mentorship_profile/activation_invalid.html',
            res.templates[0].name
        )

    def test_send_registration_email(self):
        """Test that we can send a formatted email."""
        user = UserFactory.create()
        test_domain = "127.0.0.1"
        test_uid = urlsafe_base64_encode(force_bytes(user.pk)).decode('utf-8')
        test_token = account_activation_token.make_token(user)

        # mock the email_user method so we can test how we build the email.
        user.email_user = MagicMock()

        self.request.user = user
        self.request.get_host = lambda: test_domain
        _send_registration_email(self.request, user, "mentor")
        subject, message = user.email_user.call_args[0]

        # message is dynamically generated by template, verify that certain
        # values are present.
        self.assertTrue(test_domain in message)
        self.assertTrue(test_uid in message)
        self.assertTrue(user.username in message)
        self.assertTrue(test_token in message)
        self.assertEqual(subject, "Activate your PuPPy Mentorship Account")

    def test_get_user_from_uid_valid_uid(self):
        """Test _get_user_from_uid returns correct user instance."""
        user = UserFactory.create()
        test_uid = urlsafe_base64_encode(force_bytes(user.pk))

        test_user = _get_user_from_uid(test_uid)
        self.assertEqual(user, test_user)

    def test_get_user_from_uid_invalid_uid(self):
        """Test _get_user_from_uid returns None for invalid uid."""
        test_uids = ["this is clearly not correct", True, 0, None]

        for uid in test_uids:
            self.assertTrue(_get_user_from_uid(uid) is None)

    def test_get_register_mentor_view(self):
        """Test get method with register_user_view for a mentor."""
        res = self.client.get("/signup/mentor", follow=True)

        self.assertEqual(res.status_code, 200)
        self.assertEqual(
            'mentorship_profile/register.html',
            res.templates[0].name
        )

    def test_post_register_mentor_view(self):
        """Test post valid user data with register_user_view for a mentor."""
        mentor_data = {
            "user-username": "bob",
            "user-email": "bob@example.com",
            "user-password1": "supersecret",
            "user-password2": "supersecret",
            "profile-bio": "Very personal information.",
            "mentor-areas_of_interest": "career_growth",
            "profile-years_industry_experience": "1-3",
            "mentor-mentee_capacity": "2",
        }
        res = self.client.post(
            "/signup/mentor/",
            mentor_data,
            follow=True
        )
        self.assertEqual(res.status_code, 200)
        self.assertEqual(
            'mentorship_profile/activate_notification.html',
            res.templates[0].name
        )
        user = User.objects.first()
        self.assertEqual(
            user.username,
            mentor_data["user-username"]
        )
        mentor = Mentor.objects.first()
        self.assertEqual(
            user.profile,
            mentor.profile
        )

        # Test that the account is not yet activated.
        self.assertFalse(user.profile.email_confirmed)

        # TODO: figure out is_active workflow
        # self.assertFalse(user.is_active)

        # Now test that we can't re-register the same user.
        res2 = self.client.post(
            "/signup/mentor/",
            mentor_data
        )
        self.assertTrue(
            b"A user with that username already exists." in
            res2.content
        )

    def test_post_invalid_data_register_mentor_view(self):
        """Test post invalid user data with register_user_view for a mentor."""
        invalid_mentor_data = {
            "user-username": "bob",
            "user-email": "bob@example.com",
            "user-password1": "supersecret",
            "user-password2": "supersecretLOL",
            "profile-bio": "Very personal information.",
            "mentor-areas_of_interest": "backend devops",
            "profile-years_industry_experience": "1-3",
            "mentor-mentee_capacity": "2",
        }
        res = self.client.post(
            "/signup/mentor/",
            invalid_mentor_data,
            follow=True
        )

        # Should be redirected to the same form page.
        self.assertEqual(res.status_code, 200)
        self.assertEqual(
            'mentorship_profile/register.html',
            res.templates[0].name
        )

        # User should not have been registered, users should be empty.
        users = User.objects.all()
        self.assertEqual(len(users), 0)

    def test_get_register_mentee_view(self):
        """Test get method with register_user_view for a mentee."""
        res = self.client.get("/signup/mentee/", follow=True)

        self.assertEqual(res.status_code, 200)
        self.assertEqual(
            'mentorship_profile/register.html',
            res.templates[0].name
        )

    def test_post_register_mentee_view(self):
        """Test post valid user data with register_user_view for a mentee."""
        mentee_data = {
            "user-username": "Joe",
            "user-email": "bob@example.com",
            "user-password1": "supersecret",
            "user-password2": "supersecret",
            "profile-bio": "Very personal information.",
            "profile-years_industry_experience": "0-1",
            "mentee-area_of_interest": "backend devops",
            "mentee-goals": "Accomplish all the things!",
        }
        res = self.client.post(
            "/signup/mentee/",
            mentee_data,
            follow=True
        )
        self.assertEqual(res.status_code, 200)
        self.assertEqual(
            'mentorship_profile/activate_notification.html',
            res.templates[0].name
        )
        user = User.objects.first()
        self.assertEqual(
            user.username,
            mentee_data["user-username"]
        )
        mentee = Mentee.objects.first()
        self.assertEqual(
            user.profile,
            mentee.profile
        )

        # Test that the account is not yet activated.
        self.assertFalse(user.profile.email_confirmed)

        # TODO: figure out is_active workflow
        # self.assertFalse(user.is_active)

        # Now test that we can't re-register the same user.
        res2 = self.client.post(
            "/signup/mentee/",
            mentee_data
        )
        self.assertTrue(
            b"A user with that username already exists." in
            res2.content
        )

        self.assertTrue(
            user.profile.is_mentee()
        )

        self.assertFalse(
            user.profile.is_mentor()
        )

    def test_post_invalid_data_register_mentee_view(self):
        """Test post invalid user data with register_user_view for a mentee."""
        invalid_mentee_data = {
            "user-username": "Joe",
            "user-email": "bob@example.com",
            "user-password1": "supersecret",
            "user-password2": "supersecretLOL",
            "profile-bio": "Very personal information.",
            "profile-years_industry_experience": "0-1",
            "mentee-area_of_interest": "backend devops",
            "mentee-goals": "Accomplish all the things!",
        }
        res = self.client.post(
            "/signup/mentee/",
            invalid_mentee_data,
            follow=True
        )

        # Should be redirected to the same form page.
        self.assertEqual(res.status_code, 200)
        self.assertEqual(
            'mentorship_profile/register.html',
            res.templates[0].name
        )

        # User should not have been registered, users should be empty.
        users = User.objects.all()
        self.assertEqual(len(users), 0)

    def test_invalid_signup_route_404(self):
        """Test that an invalid url for a register_user_view raises a 404."""
        invalid_urls = [
            "signup/",
            "signup/mentor_mentee",
            "signup/kermit"
            "signup/1",
            "signup/m3nt0r"
        ]

        for url in invalid_urls:
            res = self.client.get(url)
            self.assertEqual(res.status_code, 404)

    def test_get_profile_no_user_404(self):
        """Test that without a user, redirects to login."""
        res = self.client.get(reverse('private_profile'), follow=True)
        self.assertEqual(
            res.templates[0].name,
            'registration/login.html'
        )

    def test_user_not_logged_in_cannot_access(self):
        """Test that with a user, but not logged in, redirects to login."""
        UserFactory.create()
        res = self.client.get(reverse('private_profile'), follow=True)
        self.assertEqual(200, res.status_code)
        self.assertEqual(
            res.templates[0].name,
            'registration/login.html'
        )

    def login_test_user(self):
        """Login a test user."""
        self.user = User.objects.create_user(
            'test_user',
            'test_user@example.com',
            'testpassword'
        )
        self.user.profile.bio = "A simple bio."
        self.user.profile.save()
        self.user.save()
        self.client.force_login(self.user)
        return self.user

    def test_get_profile_private_view(self):
        """Test the correct profile is rendered."""
        self.login_test_user()
        res = self.client.get('/profile/', follow=True)
        self.assertEqual(200, res.status_code)
        self.assertEqual(
            'mentorship_profile/profile_private.html',
            res.templates[0].name
        )

    def test_only_get_profile_private_view(self):
        """Test that only GET requests are allowed for profile_private_view."""
        self.login_test_user()
        method_calls = [
            self.client.post,
            self.client.patch,
            self.client.put,
            self.client.options,
            self.client.delete
        ]
        for method in method_calls:
            res = method('/profile/')
            self.assertEqual(405, res.status_code)

    def test_get_profile_edit_view(self):
        """Test GET for profile_edit_view renders correct forms."""
        user = self.login_test_user()
        res = self.client.get('/profile/edit/')

        # We can verify that the correct forms rendered by checking for the
        # formatted prefix of each form type.
        self.assertContains(res, "name=\"user-")
        self.assertContains(res, "name=\"profile-")
        self.assertNotContains(res, "name=\"mentor-")
        self.assertNotContains(res, "name=\"mentee-")

        # Now make the current user a mentor, that form should render.
        Mentor(profile=self.user.profile).save()
        self.assertTrue(self.user.profile.is_mentor())
        res2 = self.client.get('/profile/edit/')
        self.assertContains(res2, "name=\"user-")
        self.assertContains(res2, "name=\"profile-")
        self.assertContains(res2, "name=\"mentor-")
        self.assertNotContains(res2, "name=\"mentee-")

        # Now make the current user a mentee, that form should render.
        Mentee(profile=self.user.profile).save()
        self.assertTrue(self.user.profile.is_mentee())
        res2 = self.client.get('/profile/edit/')
        self.assertContains(res2, "name=\"user-")
        self.assertContains(res2, "name=\"profile-")
        self.assertContains(res2, "name=\"mentor-")
        self.assertContains(res2, "name=\"mentee-")

    def test_valid_post_profile_edit_view(self):
        """Test that valid data submitted via POST updates user models."""
        user = self.login_test_user()
        test_bio = "This is my bio."
        user.profile.bio = test_bio
        user.profile.years_industry_experience = "0-1"
        user.profile.save()
        test_goals = "Learn all the things."
        Mentee(
            profile=user.profile,
            goals=test_goals
        ).save()
        test_mentor_areas_of_interest = ["career_growth"]
        Mentor(
            profile=user.profile,
            areas_of_interest=test_mentor_areas_of_interest
        ).save()
        get_res = self.client.get('/profile/edit/')
        self.assertContains(get_res, test_goals)
        self.assertContains(get_res, test_bio)
        self.assertContains(get_res, test_mentor_areas_of_interest[0])

        new_test_bio = "Learn some other things."
        test_years = "1-3"
        test_email = "test_user@example.com"
        test_area_of_interest = "data science"
        test_capacity = 4
        post_params = {
            "user-username": user.username,
            "user-email": test_email,
            "profile-bio": new_test_bio,
            "profile-years_industry_experience": test_years,
            "mentee-area_of_interest": test_area_of_interest,
            "mentee-goals": test_goals,
            "mentor-mentee_capacity": test_capacity,
            "mentor-areas_of_interest": test_mentor_areas_of_interest
        }

        post_res = self.client.post('/profile/edit/', post_params, follow=True)
        self.assertEqual(post_res.status_code, 200)
        self.assertContains(post_res, new_test_bio)

        updated_user = User.objects.get(pk=user.pk)
        self.assertEqual(updated_user.email, test_email)
        self.assertEqual(updated_user.profile.bio, new_test_bio)
        self.assertEqual(
            updated_user.profile.mentee.area_of_interest,
            test_area_of_interest
        )
        self.assertEqual(
            updated_user.profile.mentor.mentee_capacity,
            test_capacity
        )
        self.assertEqual(
            updated_user.profile.mentor.areas_of_interest,
            test_mentor_areas_of_interest
        )

    def test_invalid_post_profile_edit_view(self):
        """Test that invalid data will not be submitted."""
        user = self.login_test_user()
        user.username = "test_user"
        user.email = "test_user@example.com"
        user.save()
        test_bio = "This is my bio."
        user.profile.bio = test_bio
        user.profile.save()
        Mentor(
            profile=user.profile,
            areas_of_interest=["career_growth"]
        ).save()

        post_params = {
            "user-username": "test_user",
            "user-email": "test_user@example.com",
            "profile-bio": test_bio,
            "mentor-areas_of_interest": ["corporate taxes"],
            "profile-years_industry_experience": "1-3",
            "mentor-mentee_capacity": 4,
            "mentor-currently_accepting_mentees": True,
        }
        res = self.client.post("/profile/edit/", post_params)
        self.assertEqual(
            'mentorship_profile/profile_edit.html',
            res.templates[0].name
        )
        self.assertContains(
            res,
            "Select a valid choice. corporate taxes is not " +
            "one of the available choices."
        )

    def test_get_own_public_profile_view(self):
        """Test that GET for user's own public page.

        SHOULD:
            render user's public profile page, without private information
        """
        user = self.login_test_user()
        url = "/profile/%s/" % user.username

        res = self.client.get(url)
        self.assertEqual(
            'mentorship_profile/profile_public.html',
            res.templates[0].name
        )
        # Contact info is not publicly available
        self.assertNotContains(res, user.email)

    def test_get_public_profile_view(self):
        """Test that get return's correct info for a different user."""
        user = self.login_test_user()
        new_user = User.objects.create_user(
            'new_test_user',
            'new_test_user@example.com',
            'newtestpassword'
        )
        new_user.profile.bio = "A new simple bio."
        new_user.profile.save()
        new_user.save()

        res = self.client.get('/profile/new_test_user/')
        self.assertEquals(
            'mentorship_profile/profile_public.html',
            res.templates[0].name
        )
        self.assertContains(res, new_user.username)
        self.assertContains(res, new_user.profile.bio)

    def test_get_no_user_returns_404_public_profile(self):
        """Test that a 404 is received for a user that doesn't exist."""
        self.login_test_user()
        res = self.client.get('/profile/barry_white/')

        self.assertEquals(res.status_code, 404)
        # TODO: Create custom 404 response and test for custom response.

    def test_only_get_public_profile(self):
        """Test that GET is the only valid method for profile_public_view."""
        self.login_test_user()
        method_calls = [
            self.client.post,
            self.client.patch,
            self.client.put,
            self.client.options,
            self.client.delete
        ]
        url = '/profile/' + self.user.username + '/'
        for method in method_calls:
            res = method(url)
            self.assertEqual(405, res.status_code)
